---
layout: post
title: 메모리 관리와 ARC
date: 2018-04-02
excerpt: "GC와 ARC의 차이를 알아보자"
tags: [ios, swift, memory-manage, ARC]
comments: true
category: development
---

IOS 개발하는데 있어서 참고적으로 알고 있어야 메모리 관리에 대해 적어보려고 한다. <br/>
메모리를 관리하는데 있어서 3가지지의 방식이 존재한다.
1. 가비지 컬렉션
2. 수동 레퍼런스 카운팅 및 오토릴리즈
3. 자동 레퍼런스 카운팅

## 1. 가비지 컬렉션 (GC, Garbage Collection)
가비지 컬렉션은 JAVA를 사용해본 사람이라면 누구나 알고 있는 것이다. 동일한 것이라고 생각하면 되는데, 잠시 가비지 컬렉션의 특징에 대해 잠시 짚고 넘어가자.
가비지 컬렉션은 런타임 중(=앱이 실행되고 있는 동안)에 내가 생성했던 오브젝트가 현재 사용중인지 아닌지를 모니터링을 주기적으로 하다가,
사용중이지 않은 오브젝트가 많이 쌓이기 시작하면 불필요한 오브젝트를 제거해서 사용 가능한 메모리 공간을 확보하는 방식이다.
이런 방식때문에 아래와 같은 단점이 있다.
1. 어떤 오브젝트가 사용중인지 아닌지 확인하고 메모리를 해제하는데 별도 비용이 발생한다. 
그렇기 때문에 메모리 관리를 제대로 하지 않고 개발을 하게되면, 가비지 컬렉션이 자주 동작하게 되고 이로 인해 전체적인 앱 성능이 저하된다.
2. 가비지 컬렉션이 언제 일어나는지 개발자 입장에서 예측할 수가 없다. 그렇기 때문에 앱을 어느 상황이든 실시간으로 빠르게 이용하고 싶어하는 사용자의 입장에선 안좋은 UX경험이 될 가능성이 있다.

## 2. 수동 레퍼런스 카운팅 및 오토릴리즈
이건 쉽게 생각해서 수동으로 현재 생성한 오브젝트가 몇 군데에서 사용중인지 갯수를 카운팅하는 것이다. A를 객체를 만들고 A를 사용하고 있는 사용처가 생기면 +1, 사용 후 필요가 없으면 -1하는 개념이라고 생각하면 된다. 사실 중요한건 3번이기에 '대충 이렇군아'하고 넘어가자.

## 3. 자동 레퍼런스 카운팅 (ARC, Auto Reference Counting)
바로 위에서 말한 2번의 개념을 자동으로 컨파일러가 해주는 것이다. 여기서의 핵심은 **컴파일러**가 해준다는 것이다.
그렇기 때문에 앱을 빌드(=컴파일)하는 시점에, 2번에서 처럼 우리가 수동으로 레퍼런스 참조하는 곳에서 카운팅을 +1 또는 -1하는 코드를 넣어야했던 것을 컴파일러가 자동으로 대신해주는 것이다.

## 가비지 컬렉션 != ARC
많은 이들이 가비지 컬렉션과 ARC을 동일한 것으로 착각하는데, 그렇지 않다. ARC는 가비지 컬렉션과 다르게 **런타임이 아닌 컴파일 단계에서 처리**가 된다.
이때문에 ARC는 런타임 중(=앱이 실행되고 있는 동안)에 메모리 관리를 위해 별도 비용이 발생하지 않는다. 
또한 1번에서 언급했던, 가비지 컬렉션이 런타임중에 실행되면서 발생하는 두가지 단점들이 ARC에서는 모두 해결이 된다.